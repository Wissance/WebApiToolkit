using System;
using System.Reflection;
using System.Reflection.Emit;
using Wissance.WebApiToolkit.Core.Data;
using Wissance.WebApiToolkit.Core.Managers;
using Wissance.WebApiToolkit.Data.Entity;
using Wissance.WebApiToolkit.Ef.Controllers;

namespace Wissance.WebApiToolkit.Ef.Generators
{
    internal static class OnTheFlyServicesGenerator
    {
        public static Tuple<Assembly, string> GenerateController<TObj, TId, TFilter>(string assemblyName, string controllerName, 
            bool saveOnDisk, ControllerType controllerType)
            where TObj: class, IModelIdentifiable<TId>
            where TId: IComparable
            where TFilter: class, IReadFilterable
        {
            try
            {
                // todo(UMV): combine controllers in one assembly
                AssemblyName name = new AssemblyName(assemblyName);
                AssemblyBuilderAccess access = saveOnDisk ? AssemblyBuilderAccess.RunAndCollect : AssemblyBuilderAccess.Run;
                AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(name, access);
                
                string fullControllerName = $"{controllerName}Controller";
                ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule($"AutoGenerated{fullControllerName}");
                Type basicControllerType = GetAppropriateBaseControllerType<TObj, TId, TFilter>(controllerType);
                TypeBuilder typeBuilder = moduleBuilder.DefineType(fullControllerName,
                    TypeAttributes.Public | TypeAttributes.Class, basicControllerType);
                ConstructorBuilder constructorBuilder = typeBuilder.DefineConstructor(
                    MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName,
                    CallingConventions.Standard,
                    new Type[] {typeof(IModelManager<TObj, TObj, TId>)});
                ILGenerator ilGenerator = constructorBuilder.GetILGenerator();
                // load this
                ilGenerator.Emit(OpCodes.Ldarg_0);
                // load arg0 -> manager
                ilGenerator.Emit(OpCodes.Ldarg_1);
                ConstructorInfo baseCtor = basicControllerType.GetConstructor(new []{typeof(IModelManager<TObj, TObj, TId>)});
                ilGenerator.Emit(OpCodes.Call, baseCtor);
                ilGenerator.Emit(OpCodes.Ret); // Return from the constructor
                Type t = typeBuilder.CreateType();
                Assembly controllerAssembly = Assembly.GetAssembly(t);
                return new Tuple<Assembly, string>(controllerAssembly, String.Empty);
            }
            catch (Exception e)
            {
                return new Tuple<Assembly, string>(null, e.Message);
            }
        }
        
        private static Type GetAppropriateBaseControllerType<TObj, TId, TFilter>(ControllerType controllerType)
            where TObj: class, IModelIdentifiable<TId>
            where TId: IComparable
            where TFilter: class, IReadFilterable
        {
            switch (controllerType)
            {
                case ControllerType.ReadOnly:
                    return typeof(GenericReadOnlyController<TObj, TObj, TId, TFilter>);
                case ControllerType.FullCrud:
                    return typeof(GenericCrudController<TObj, TObj, TId, TFilter>);
                case ControllerType.Bulk:
                    return typeof(GenericBulkController<TObj, TObj, TId, TFilter>);
                default:
                    return typeof(GenericCrudController<TObj, TObj, TId, TFilter>);
            }
        }
    }
}